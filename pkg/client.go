// Code generated by counterfeiter. DO NOT EDIT.
package httpmoq

import (
	"io"
	"net/http"
	"net/url"
	"sync"
)

func NewClient() *Client {
	return &Client{}
}

type Client struct {
	CloseIdleConnectionsStub        func()
	closeIdleConnectionsMutex       sync.RWMutex
	closeIdleConnectionsArgsForCall []struct {
	}
	DoStub        func(*http.Request) (*http.Response, error)
	doMutex       sync.RWMutex
	doArgsForCall []struct {
		arg1 *http.Request
	}
	doReturns struct {
		result1 *http.Response
		result2 error
	}
	doReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	GetStub        func(string) (*http.Response, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 *http.Response
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	HeadStub        func(string) (*http.Response, error)
	headMutex       sync.RWMutex
	headArgsForCall []struct {
		arg1 string
	}
	headReturns struct {
		result1 *http.Response
		result2 error
	}
	headReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PostStub        func(string, string, io.Reader) (*http.Response, error)
	postMutex       sync.RWMutex
	postArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 io.Reader
	}
	postReturns struct {
		result1 *http.Response
		result2 error
	}
	postReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PostFormStub        func(string, url.Values) (*http.Response, error)
	postFormMutex       sync.RWMutex
	postFormArgsForCall []struct {
		arg1 string
		arg2 url.Values
	}
	postFormReturns struct {
		result1 *http.Response
		result2 error
	}
	postFormReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Client) CloseIdleConnections() {
	fake.closeIdleConnectionsMutex.Lock()
	fake.closeIdleConnectionsArgsForCall = append(fake.closeIdleConnectionsArgsForCall, struct {
	}{})
	stub := fake.CloseIdleConnectionsStub
	fake.recordInvocation("CloseIdleConnections", []interface{}{})
	fake.closeIdleConnectionsMutex.Unlock()
	if stub != nil {
		fake.CloseIdleConnectionsStub()
	}
}

func (fake *Client) CloseIdleConnectionsCallCount() int {
	fake.closeIdleConnectionsMutex.RLock()
	defer fake.closeIdleConnectionsMutex.RUnlock()
	return len(fake.closeIdleConnectionsArgsForCall)
}

func (fake *Client) CloseIdleConnectionsCalls(stub func()) {
	fake.closeIdleConnectionsMutex.Lock()
	defer fake.closeIdleConnectionsMutex.Unlock()
	fake.CloseIdleConnectionsStub = stub
}

func (fake *Client) Do(arg1 *http.Request) (*http.Response, error) {
	fake.doMutex.Lock()
	ret, specificReturn := fake.doReturnsOnCall[len(fake.doArgsForCall)]
	fake.doArgsForCall = append(fake.doArgsForCall, struct {
		arg1 *http.Request
	}{arg1})
	stub := fake.DoStub
	fakeReturns := fake.doReturns
	fake.recordInvocation("Do", []interface{}{arg1})
	fake.doMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) DoCallCount() int {
	fake.doMutex.RLock()
	defer fake.doMutex.RUnlock()
	return len(fake.doArgsForCall)
}

func (fake *Client) DoCalls(stub func(*http.Request) (*http.Response, error)) {
	fake.doMutex.Lock()
	defer fake.doMutex.Unlock()
	fake.DoStub = stub
}

func (fake *Client) DoArgsForCall(i int) *http.Request {
	fake.doMutex.RLock()
	defer fake.doMutex.RUnlock()
	argsForCall := fake.doArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) DoReturns(result1 *http.Response, result2 error) {
	fake.doMutex.Lock()
	defer fake.doMutex.Unlock()
	fake.DoStub = nil
	fake.doReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) DoReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.doMutex.Lock()
	defer fake.doMutex.Unlock()
	fake.DoStub = nil
	if fake.doReturnsOnCall == nil {
		fake.doReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.doReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) Get(arg1 string) (*http.Response, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *Client) GetCalls(stub func(string) (*http.Response, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *Client) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) GetReturns(result1 *http.Response, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) GetReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) Head(arg1 string) (*http.Response, error) {
	fake.headMutex.Lock()
	ret, specificReturn := fake.headReturnsOnCall[len(fake.headArgsForCall)]
	fake.headArgsForCall = append(fake.headArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.HeadStub
	fakeReturns := fake.headReturns
	fake.recordInvocation("Head", []interface{}{arg1})
	fake.headMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) HeadCallCount() int {
	fake.headMutex.RLock()
	defer fake.headMutex.RUnlock()
	return len(fake.headArgsForCall)
}

func (fake *Client) HeadCalls(stub func(string) (*http.Response, error)) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = stub
}

func (fake *Client) HeadArgsForCall(i int) string {
	fake.headMutex.RLock()
	defer fake.headMutex.RUnlock()
	argsForCall := fake.headArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Client) HeadReturns(result1 *http.Response, result2 error) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = nil
	fake.headReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) HeadReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = nil
	if fake.headReturnsOnCall == nil {
		fake.headReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.headReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) Post(arg1 string, arg2 string, arg3 io.Reader) (*http.Response, error) {
	fake.postMutex.Lock()
	ret, specificReturn := fake.postReturnsOnCall[len(fake.postArgsForCall)]
	fake.postArgsForCall = append(fake.postArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 io.Reader
	}{arg1, arg2, arg3})
	stub := fake.PostStub
	fakeReturns := fake.postReturns
	fake.recordInvocation("Post", []interface{}{arg1, arg2, arg3})
	fake.postMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) PostCallCount() int {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	return len(fake.postArgsForCall)
}

func (fake *Client) PostCalls(stub func(string, string, io.Reader) (*http.Response, error)) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = stub
}

func (fake *Client) PostArgsForCall(i int) (string, string, io.Reader) {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	argsForCall := fake.postArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Client) PostReturns(result1 *http.Response, result2 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	fake.postReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) PostReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	if fake.postReturnsOnCall == nil {
		fake.postReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.postReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) PostForm(arg1 string, arg2 url.Values) (*http.Response, error) {
	fake.postFormMutex.Lock()
	ret, specificReturn := fake.postFormReturnsOnCall[len(fake.postFormArgsForCall)]
	fake.postFormArgsForCall = append(fake.postFormArgsForCall, struct {
		arg1 string
		arg2 url.Values
	}{arg1, arg2})
	stub := fake.PostFormStub
	fakeReturns := fake.postFormReturns
	fake.recordInvocation("PostForm", []interface{}{arg1, arg2})
	fake.postFormMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Client) PostFormCallCount() int {
	fake.postFormMutex.RLock()
	defer fake.postFormMutex.RUnlock()
	return len(fake.postFormArgsForCall)
}

func (fake *Client) PostFormCalls(stub func(string, url.Values) (*http.Response, error)) {
	fake.postFormMutex.Lock()
	defer fake.postFormMutex.Unlock()
	fake.PostFormStub = stub
}

func (fake *Client) PostFormArgsForCall(i int) (string, url.Values) {
	fake.postFormMutex.RLock()
	defer fake.postFormMutex.RUnlock()
	argsForCall := fake.postFormArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Client) PostFormReturns(result1 *http.Response, result2 error) {
	fake.postFormMutex.Lock()
	defer fake.postFormMutex.Unlock()
	fake.PostFormStub = nil
	fake.postFormReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) PostFormReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.postFormMutex.Lock()
	defer fake.postFormMutex.Unlock()
	fake.PostFormStub = nil
	if fake.postFormReturnsOnCall == nil {
		fake.postFormReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.postFormReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *Client) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeIdleConnectionsMutex.RLock()
	defer fake.closeIdleConnectionsMutex.RUnlock()
	fake.doMutex.RLock()
	defer fake.doMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.headMutex.RLock()
	defer fake.headMutex.RUnlock()
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	fake.postFormMutex.RLock()
	defer fake.postFormMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Client) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ *Client = new(Client)
